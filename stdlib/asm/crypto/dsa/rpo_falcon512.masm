use.std::crypto::hashes::rpo
use.std::math::u64

# CONSTANTS
# =================================================================================================

const.J=77321994752
const.M=12289
const.M_HALF=6144 # (M-1) / 2
const.SQUARE_NORM_BOUND=34034726

# MODULAR REDUCTION FALCON PRIME
# =============================================================================================

#! Given dividend ( i.e. a u64 given by its lower and higher u32 decomposition ) on the stack,
#! this routine computes c = a % 12289
#!
#! Expected stack state
#!
#! [a_hi, a_lo, ...]
#!
#! Output stack state looks like
#!
#! [c, ...] | c = a % 12289
#!
#! Cycles: 31
export.mod_12289
    adv.push_falcon_div
    # the advice stack contains now [qhi, qlo, r, ...] where q = qhi * 2^32 + qlo is quotient
    # and r is remainder

    adv_push.2
    u32assert2
    # => [qlo, qhi, a_hi, a_lo, ...]

    push.M
    u32overflowing_mul
    # => [overflow, M * qlo % 2^32, qhi, a_hi, a_lo, ...]

    movup.2
    push.M
    # => [M, qhi, overflow, M * qlo % 2^32, a_hi, a_lo, ...]
    u32overflowing_madd
    # => [t1, t0, M * qlo % 32, a_hi, a_lo, ...] where t = t1 * 2^32 + t0 and t = M * qhi + overflow
    # Note by the bound on x - r = q * M, we are guaranteed that t1 = 0
    drop
    # => [M * q / 2^32, (M * q) % 2^32, a_hi, a_lo, ...]
    # => [res_hi, res_lo, a_hi, a_lo, ...]

    adv_push.1
    dup u32lt.M assert 
    # => [r, res_hi, res_lo, a_hi, a_lo, ...]

    dup
    movup.3
    u32overflowing_add
    # => [flag, (res_lo + r) % 2^32, r, res_hi, a_hi, a_lo, ...] where u = uhi * 2^32 + ulo and u = (res_lo + r) / 2^32

    movup.3
    u32overflowing_add
    # => [flag, final_res_hi, final_res_lo, r, a_hi, a_lo, ...] flag should be 0 by the bound on inputs
    drop
    # => [final_res_hi, final_res_lo, r, a_hi, a_lo, ...]
    
    movup.3
    assert_eq
    movup.2
    assert_eq
    # => [r, ...]
end

# HASH-TO-POINT
# =============================================================================================

#! Takes as input a message digest, a nonce of size 40 bytes represented as 8 field elements
#! and a pointer. The procedure absorbs MSG and NONCE into a fresh RPO state and squeezes the
#! coefficients of a polynomial c representing the hash-to-point of (MSG || NONCE). The coefficients
#! are then saved in the memory region [c_ptr, c_ptr + 128).
#! This implementation of the `hash_to_point` procedure avoids the rejection-sampling step
#! required in the per-the-spec algorithm by using the observation on page 31 in
#! https://falcon-sign.info/falcon.pdf
#!
#! Input: [c_ptr, MSG, NONCE1, NONCE0, ...]
#! Output: [...]
#!
#! Cycles: 1327
export.hash_to_point.2
    # Move pointer out of the way
    movdn.12

    # Store MSG for later absorption
    loc_storew.1 dropw

    # Absorb the nonce
    padw movdnw.2
    hperm

    # Absorb the message
    swapw loc_loadw.1 swapw hperm

    # Squeeze the coefficients and save them
    repeat.63
        swapw dup.12
        mem_storew
        swapw dup.12 add.2 swap.13 add.1
        mem_storew
        hperm
    end

    # Save the last remaining coefficients
    dup.12 add.1 mem_storew dropw
    movup.8 mem_storew dropw

    # Clean up the stack
    dropw
end


# PROBABILISTIC POLYNOMIAL MULTIPLICATION IN Z_Q[x]
# =============================================================================================

#! Helper procedure to push result of horner_eval_* from advice stack to op stack.
proc.update_acc
    swapw.3
    adv_push.1
    swap.4 drop
    adv_push.1
    swap.3 drop
    swapw.3
end

#! Takes as input PK, the hash of the coefficients of the polynomial `h` representing the expanded
#! public key, and a pointer to the memory location where the coefficients of the polynomial `h`
#! will be stored.
#! The procedure loads `h` from the advice stack and compares its hash with the provided hash `PK`.
#! It then loads the polynomial `s2` representing the signature from the advice stack and lays it
#! in memory right after `h`.
#! It then loads the claimed polynomial `h * s2` in Z_Q[x] where Q is the Miden VM prime from
#! the advice stack and lays it right after `s2`.
#! The hash of `h`, `s2` and the claimed product is also computed and the first two field elements
#! of the digest (i.e., the Fiat-Shamir challenge) are returned on the stack alongside
#! the incremented pointer.
#!
#! Checks that pi == h * s2 in Z_Q[x] by evaluating both sides at a random point.
#!
#! Input: [ptr, PK, ...]
#! Output: [...]
#!
#! Cycles: 7065
export.load_h_s2_and_product.4

    # 1) Save ptr to polynomials as we will be using it in several places
    dup
    loc_store.3
    
    # 2) Set up the stack for loading the coefficients of the polynomials, evaluating and hashing them
    
    ## a) Set up the accumulator for `horner_eval_base` and the memory pointers
    push.0.0
    locaddr.1
    movup.3

    ## b) Save PK to later compare it with the hash of the h polynomial
    swapw
    loc_storew.0
    # => [PK, ptr, alpha_inv, acc1, acc0, ...]

    ## c) Prepare the capacity portion of the state of the hasher
    padw swapw
    # => [Y, 0, 0, 0, 0, ptr, alpha_inv, acc1, acc0, ...]

    ## d) Load the evaluation point tau from the advice tape, compute its inverse and save both
    ## Note that we will evaluate the polynomials at `tau_inv = tau^{-1}` as we are loading the coefficients
    ## in the normal order i.e., not in reversed order required for Horner evaluation.
    ## This means that the equality we will be checking is 
    ## pi(tau_inv) * tau^1023 == h(tau_inv) * tau^511 * s2(tau_inv) * tau^511
    ##
    ## which simplifies to
    ##
    ## pi(tau_inv) * tau == h(tau_inv) * s2(tau_inv)
    adv_push.2 
    dup.1 dup.1 ext2inv
    push.0.0
    loc_storew.1

    ## e) Store the random evaluation point. We will later check that it is the correct one.
    movup.2 drop
    movup.2 drop
    loc_storew.2
    # => [Y, Y, 0, 0, 0, 0, ptr, alpha_inv, acc1, acc0, ...]

    # 3) Load the coefficients of the h polynomial and evaluate them at tau_inv
    repeat.64
        adv_pipe

        dupw.1
        u32assert2
        push.M u32lt assert
        push.M u32lt assert
        u32assert2
        push.M u32lt assert
        push.M u32lt assert

        dupw
        u32assert2
        push.M u32lt assert
        push.M u32lt assert
        u32assert2
        push.M u32lt assert
        push.M u32lt assert

        adv.push_horner_base
        exec.update_acc

        hperm
    end


    # 4) Load PK, the saved claimed hash of h, and compare
    loc_loadw.0
    movup.4 assert_eq
    movup.3 assert_eq
    movup.2 assert_eq
    assert_eq

    # 5) Load s2 and evaluate at tau_inv (Due to the final norm test we do not need to range check the s2 coefficients)
    
    ## a) Reset the accumulator, update the pointers and set up the state of the hasher
    push.0.0
    locaddr.1
    loc_load.3 add.128
    swapw 
    padw padw

    ## b) Load and evaluate s2 at tau_inv
    repeat.64
        adv_pipe 
        
        adv.push_horner_base
        exec.update_acc
        
        hperm
    end

    # 6) Load claimed h * s2 in Z_Q[x]

    ## a) Reset the accumulator, update the pointers and set up the state of the hasher
    push.0.0
    locaddr.1
    loc_load.3 add.256
    movdnw.3
    repeat.128
        adv_pipe

        adv.push_horner_base
        exec.update_acc
        
        hperm
    end

    # 7) Check that the challenge we computed the evaluations with is the correct one

    ## a) Extract the expected challenge from the digest and leave a garbage word to load
    ##    the challenge we got from the advice stack
    dropw
    swapw drop drop 

    ## b) Load from memory the challenge we got from the advice stack and assert equality between
    ##    the two challenges
    loc_loadw.2
    drop drop
    dup.2 assert_eq
    dup.2 assert_eq

    # 8) Assert the equality pi(tau_inv) * tau == h(tau_inv) * s2(tau_inv)

    ## a) Compute the left hand side of the equation
    movup.2 drop
    movup.2 drop
    ext2mul

    ## b) Compute the right hand side of the equation
    movup.2 drop
    movup.2 drop
    swapw
    drop drop
    movup.5 movup.5
    ext2mul

    ## c) Assert equality
    movup.2     
    assert_eq
    assert_eq
    # => [...]
end


# SQUARE NORM OF Z_q[x]/(phi) POLYNOMIALS
# =============================================================================================

#! Normalizes an `e` in [0, q) to be in [-(q-1) << 1, (q-1) << 1) and returns its square norm.
#!
#! We use the following formula to do so:
#! normalize(e) = e^2 - phi * (2*q*e - q^2) where phi := (e > (q - 1)/2)
#!
#! The formula implements:
#!
#! if e > (q-1)/2:
#!   return (q - e)^2
#! else:
#!   return e^2
#!
#! The use of the formula avoids using the if-else block.
#!
#! Input: [e, ...]
#! Output [norm(e)^2, ...]
#!
#! Cycles: 20
export.norm_sq

    dup
    dup mul
    #=> [e^2, e, ...]

    push.M_HALF
    dup.2
    u32lt
    #=> [phi, e^2, e, ...]

    movup.2
    mul.24578       # 2*q
    push.151019521  # q^2
    sub
    #=> [2*q*e - q^2, phi, e^2, ...]

    mul sub
    #=> [norm(e)^2, ...]
end

#! Given a tuple (u, w, v), we want to compute (v - (u + (- w % q) % q) % q), where:
#!
#! 1. v is a field element given by its u32 decomposition i.e., (c_lo, c_hi) such that 
#!    v = c_hi * 2**32 + c_lo
#! 2. w is a field element representing the (i+512)-th coefficient of the product polynomial
#!    pi (i.e., h * s2). We are guaranteed that w is at most 512 * (q-1)^2.
#! 3. u is a field element representing the i-th coefficient of the product polynomial
#!    pi (i.e., h * s2). We are guaranteed that u is at most 512 * (q-1)^2.
#!
#! We can avoid doing three modular reductions by using the following facts:
#!
#! 1. q is much smaller than the Miden prime Q. Precisely, q * 2^50 < Q
#! 2. The coefficients of the product polynomial, u and w, are strictly less than J := 512 * q^2.
#! 3. The coefficients of c are at most q - 1.
#!
#! This means that we can substitute (v - (u + (- w % q) % q) % q) with  v + w + J - u 
#! (note J % q= 0) without risking Q-underflow but we can still overflow.
#! For this reason, we use the u32 decomposition of v and perform the addition of
#! v and w + J - u as u64. Note that |w + J - u| <= 1024 * (q - 1)^2
#! and hence there is the possibility of an overflow when we add v and w + J - u as u64.
#! When there is an overflow, we add 10952, which is equal to 2^32 % q, to the upper u32 limb of 
#! the result of (v + (w + J - u)). Note that since |w + J - u| <= 1024 * (q-1)^2 < 2^38, and
#! 10952 < q, we are guaranteed that this final u32 addition to the upper limb will not overflow.
#!
#! To get the final result we reduce (v + w + J - u) modulo q.
#!
#! Input: [pi0, pi512 + J, c_hi, c_lo, ...]
#! Output: [e, ...]
#!
#! Cycles: 45
export.diff_mod_q

    # 1) Subtract
    sub
    #=> [pi512 + J - pi, c_hi, c_lo, ...]

    # 2) u32split first u64
    u32split
    #=> [tmp_hi, tmp_lo, c_hi, c_lo, ...]
  
    # 3) Add the two u64-s
    exec.u64::overflowing_add
    #=> [flag, res_hi, res_lo, ..]
    
    # 4) Handle potential overflow in the u64 addition
    push.10952 # 2^32 mod q
    push.0
    #=> [0, 10952, flag, res_hi, res_lo, ..]
    swap.2
    #=> [flag, 10952, 0, res_hi, res_lo, ..]
    cdrop
    add
    #=> [res_hi, res_lo, ..]

    # 5) Reduce modulo q
    exec.mod_12289
    #=> [e, ...]
end

#! Takes a pointer to a polynomial pi of degree less than 1024 with coefficients in Z_Q and
#! a polynomial c of degree 512 with coefficients also in Z_Q, where Q is the Miden prime.
#! The goal is to compute s1 = c - pi  = c - h * s2 in Z_q[x]/(phi) where q is the Falcon prime.
#! The pointer pi_ptr points both to pi and c through the relation c_ptr = pi_ptr + offset
#! where offset := 1281.
#! The naive way to compute s1 would be to first reduce the polynomial pi modulo the Falcon
#! prime q and then modulo the irreducible polynomial phi = x^512 + 1. Then we would need to negate
#! the coefficients of pi modulo q and only then can we add these coefficients to the coefficients
#! of c and then reduce the result modulo q one more time.
#! Knowing that the end goal of computing c is to compute its norm squared, we can do better.
#!
#! We can compute s1 in a single pass by delaying the q-modular reduction til the end. This can
#! be achieved through a careful analysis of the computation of the difference between pi and c.
#!
#! The i-th coefficient s1_i of s1 is equal to c_i - (pi_i - pi_{512 + i}) which is equal to
#! c_i  + pi_{512 + i} - pi_i. Now, we know that the size of the pi_i coefficients is bounded by
#! J := 512 * q^2 and this means that J + pi_{512 + i} - pi_i does not Q-underflow and since
#! J = 0 modulo q, the addition of J does not affect the final result. It is also important to
#! note that adding J does not Q-overflow by virtue of q * 2^50 < Q.
#! All of the above implies that we can compute s1_i with only one modular reduction at the end,
#! in addition to one modular reduction applied to c_i.
#! Moreover, since we are only interested in the square norm of s1_i, we do not have to store
#! s1_i and then load it at a later point, and instead we can immediately follow the computation
#! of s1_i with computing its square norm.
#! After computing the square norm of s1_i, we can accumulate into an accumulator to compute the
#! sum of the square norms of all the coefficients of polynomial c. Using the overflow stack, this
#! can be delayed til the end.
#!
#! Input: [pi_ptr, ...]
#! Output: [norm_sq(s1), ...]
#!
#! Cycles: 40966
export.compute_s1_norm_sq
    repeat.128
        # 1) Load the next 4 * 3 coefficients
        # load the next four pi_i
        padw
        dup.4
        mem_loadw

        # load the next four pi_{i+512}
        padw
        dup.8 add.128
        mem_loadw

        # load the next four c_i
        padw
        dup.12 add.256
        mem_loadw
        #=> [C, PI_{i+512}, PI, pi_ptr, ...]

        # 2) Compute the squared norm of (i + 0)-th coefficient of s1

        u32split
        #=> [c0_hi, c0_lo, c1, c2, c3, PI_{i+512}, PI, pi_ptr, ...]
        movup.5
        push.J add
        #=> [pi512_0, c0_hi, c0_lo, c1, c2, c3, pi512_1, pi512_2, pi512_3, PI, pi_ptr, ...]
        movup.9
        #=> [pi0, pi512_0, c_hi, c_lo, c1, c2, c3, pi512_1, pi512_2, pi512_3, pi1, pi2, pi3, pi_ptr, ...]
        exec.diff_mod_q
        #=> [e, c1, c2, c3, pi512_1, pi512_2, pi512_3, pi1, pi2, pi3, pi_ptr, ...]
        exec.norm_sq
        #=> [norm(e)^2, ...]

        # Move the result out of the way so that we can process the remaining coefficients
        movdn.10
        #=> [c1, c2, c3, pi512_1, pi512_2, pi512_3, pi1, pi2, pi3, pi_ptr, e0, ...]

        # 3) Compute the squared norm of (i + 1)-th coefficient of s1

        u32split
        #=> [c1_hi, c1_lo, c2, c3, pi512_1, pi512_2, pi512_3, pi1, pi2, pi3, pi_ptr, e0, ...]
        movup.4
        #=> [pi512_1, c1_hi, c1_lo, c2, c3, pi512_2, pi512_3, pi2, pi3, pi_ptr, e0, ...]
        push.J add
        movup.7
        #=> [pi1, pi512_1, c1_hi, c1_lo, c2, c3, pi512_2, pi512_3, pi2, pi3, pi_ptr, e0, ...]
        exec.diff_mod_q
        exec.norm_sq
        #=> [e, c2, c3, pi512_2, pi512_3, pi2, pi3, pi_ptr, e0, ...]

        movdn.7
        #=> [c2, c3, pi512_2, pi512_3, pi2, pi3, pi_ptr, e0, e1, ...]

        # 4) Compute the squared norm of (i + 2)-th coefficient of s1

        u32split
        #=> [c2_hi, c2_lo, c3, pi512_2, pi512_3, pi2, pi3, pi_ptr, e0, e1, ...]
        movup.3
        push.J add
        #=> [pi512_2, c2_hi, c2_lo, c3, pi512_3, pi2, pi3, pi_ptr, e0, e1, ...]
        movup.5
        #=> [pi2, pi512_2, c2_hi, c2_lo, c3, pi512_3, pi3, pi_ptr, e0, e1, ...]
        exec.diff_mod_q
        exec.norm_sq

        movdn.4
        #=> [c3, pi512_3, pi3, pi_ptr, e, e, e, ...]

        # 5) Compute the squared norm of (i + 3)-th coefficient of s1

        u32split
        #=> [c3_hi, c3_lo, pi512_3, pi3, pi_ptr, e0, e1, e2, ...]
        movup.2 push.J add
        movup.3
        #=> [pi3, pi512_3, c3_hi, c3_lo, pi_ptr, e0, e1, e2, ...]
        exec.diff_mod_q
        #=> [e3, pi_ptr, e0, e1, e2, ...]
        exec.norm_sq
        #=> [e3, pi_ptr, e0, e1, e2, ...]

        swap
        #=> [pi_ptr, e3, e0, e1, e2, ...]

        # 6) Increment the pointer
        add.1
    end

    # Sum up the squared norm of all the coefficients of s1
    drop    # drop the pointer
    repeat.511
        add
    end
    #=> [norm_sq(s1), ...]
end

#! Compute the square norm of the polynomial s2 given a pointer to its coefficients.
#!
#! Input: [s2_ptr, ...]
#! Output: [norm_sq(s2), ...]
#!
#! Cycles: 11137
export.compute_s2_norm_sq
    repeat.128
        padw
        dup.4
        mem_loadw

        exec.norm_sq
        swap
        exec.norm_sq
        add
        swap
        exec.norm_sq
        add
        swap
        exec.norm_sq
        add
        swap
        add.1
    end
    drop
    repeat.127
        add
    end
end


# FALCON SIGNATURE VERIFICATION ALGORITHM
# =============================================================================================

#! Verifies a signature against a public key and a message. The procedure gets as inputs the hash
#! of the public key and the hash of the message via the operand stack. The signature is provided
#! via the advice stack.
#! The signature is valid if and only if the procedure returns.
#!
#! Input: [PK, MSG, ...]
#! Output: [...]
#!
#! Cycles: ~ 60500
export.verify.640

    # 1) Generate a Falcon signature using the secret key associated to PK on message MSG.
    adv.push_sig.rpo_falcon512
    #=> [PK, MSG, ...]

    # 2) Load the public key polynomial h and the signature polynomial s2 and the product of
    # the two polynomials pi := h * s2 in Z_Q[x]. This also checks that h hashes to the provided
    # digest PK. While loading the polynomials, the first half of the digest of hashing the three
    # polynomials and is used to check that we indeed have pi := h * s2 in Z_Q[x] by checking that
    # pi(tau) = h(tau) * s2(tau) where tau is a random (Fiat-Shamir) challenge resulting
    # from hashing h, s2 and pi.

    locaddr.0
    exec.load_h_s2_and_product
    #=> [MSG, ...]      (Cycles: 7065)

    # 3) Load the NONCE from the advice provider. This is encoded as 8 field elements

    padw adv_loadw
    padw adv_loadw
    #=> [NONCE1, NONCE0, MSG, ...]

    # 4) Compute the hash-to-point of the message MSG from the provided NONCE and save
    # the resulting polynomial c in the memory region [c_ptr, c_ptr + 128)

    movupw.2
    locaddr.512
    exec.hash_to_point
    #=> [...]                                       (Cycles: 1327)

    # 5) Compute the squared norm of s1 := c - h * s2 (in Z_q[x]/(phi))

    locaddr.256
    #=> [pi_ptr, ...]

    exec.compute_s1_norm_sq
    #=> [norm_sq(s1), ...]                          (Cycles: 40966)

    # 6) Compute the squared norm of s2

    locaddr.128
    #=> [s2_ptr, norm_sq(s1), ...]

    exec.compute_s2_norm_sq
    #=> [norm_sq(s2), norm_sq(s1), ...]             (Cycles: 11137)

    # 7) Check that ||(s1, s2)||^2 < K

    add
    #=> [norm_sq(s1) + norm_sq(s2), ...]

    push.SQUARE_NORM_BOUND
    u32assert2 u32lt assert
    #=> [...]                                       (Cycles: 8)
end
